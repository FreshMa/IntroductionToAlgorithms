1. 首先，快排是一种分治算法。但是，它不需要显式的Combine步骤，因为在Conquer步骤时已经将每个子数组都排好序了，且空间复杂度是O（1），自然，由这些子数组合成的数组也是有序的
2. 时间复杂度是O(nlgn)，最坏时间复杂度是O(n<sup>2</sup>)
3. 快排的主要思想是在数组A中找到一个哨兵值，将不大于它的元素放到它的左边，大于它的元素放到它的右边
4. 在实现上，算法使用一个变量pivot来保存哨兵值（一般是子数组A[p~r]的最后一个元素A[r]），用两个指针i和j，其中指针i是一个重要的分界线，它具有以下性质：
  - 对于所有的p<=k<=i，A[k] <= pivot=A[r]
  - 对于所有的i < k <= j，A[k] > pivot=A[r]
  - 对于所有的j < k < r，A[k]与pivot的关系未定，因为还未扫描
  - 对于k=r，A[k]==A[r]
  - 这些性质可以作为该算法的循环不变量，即loop invariant
5. 根据这些性质，我们可以发现，i始终不大于j，i位于j的循环里面，且只有满足A[j]<=x时，i才会增加1，并交换A[i]和A[j]的位置。所以i指向的永远是已扫描过的元素中最后一个不大于哨兵的值。
